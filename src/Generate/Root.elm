module Generate.Root exposing (generate)

{-| This is the base `{Namespace}` file that has everything you need to launch queries.
-}

import Elm
import Elm.Annotation as Type
import Gen.GraphQL.Engine as Engine
import Gen.Platform.Cmd
import Gen.Result
import Generate.Scalar
import GraphQL.Schema exposing (Namespace)


groups =
    { mutations = "Mutations"
    , queries = "Queries"
    , optional = "Optional Inputs"
    , maps = "Batching and Mapping"
    }


groupOrder :
    { group : Maybe String
    , members : List String
    }
    -> Int
groupOrder group =
    case group.group of
        Nothing ->
            1000

        Just name ->
            if name == groups.queries then
                1

            else if name == groups.mutations then
                2

            else if name == groups.optional then
                3

            else
                4


generate : Namespace -> GraphQL.Schema.Schema -> Elm.File
generate namespace schema =
    Elm.fileWith [ namespace.namespace ]
        { docs =
            \docs ->
                "This is a file generated by `elm-gql` when you ran `elm-gql init`!"
                    :: "It's yours now to do whatever you want with."
                    :: "This file does include decoders and encoders for all the Scalars for your GQL endpoint.  You'll need to make sure they are implemented correctly."
                    :: (docs
                            |> List.sortBy groupOrder
                            |> List.map Elm.docs
                       )
        , aliases = []
        }
        ([ Elm.alias "Query"
            (Engine.annotation_.selection
                Engine.annotation_.query
                (Type.var "data")
            )
            |> Elm.exposeWith
                { exposeConstructor = True
                , group = Just groups.queries
                }
         , Elm.alias "Mutation"
            (Engine.annotation_.selection
                Engine.annotation_.mutation
                (Type.var "data")
            )
            |> Elm.exposeWith
                { exposeConstructor = True
                , group = Just groups.mutations
                }
         , Elm.alias "Selection"
            (Engine.annotation_.selection
                (Type.var "source")
                (Type.var "data")
            )
         , Elm.declaration "query"
            (Elm.fn2
                ( "sel", Just (Type.namedWith [] "Query" [ Type.var "data" ]) )
                ( "options"
                , Just
                    (Type.record
                        [ ( "headers", Type.list (Type.named [ "Http" ] "Header") )
                        , ( "url", Type.string )
                        , ( "timeout", Type.maybe Type.float )
                        , ( "tracker", Type.maybe Type.string )
                        ]
                    )
                )
                (\sel options ->
                    Engine.call_.query sel options
                        |> Elm.withType
                            (Gen.Platform.Cmd.annotation_.cmd
                                (Gen.Result.annotation_.result
                                    Engine.annotation_.error
                                    (Type.var "data")
                                )
                            )
                )
            )
            |> Elm.exposeWith
                { exposeConstructor = True
                , group = Just groups.queries
                }
         , Elm.declaration "mutation"
            (Elm.fn2
                ( "sel", Just (Type.namedWith [] "Mutation" [ Type.var "data" ]) )
                ( "options"
                , Just
                    (Type.record
                        [ ( "headers", Type.list (Type.named [ "Http" ] "Header") )
                        , ( "url", Type.string )
                        , ( "timeout", Type.maybe Type.float )
                        , ( "tracker", Type.maybe Type.string )
                        ]
                    )
                )
                (\sel options ->
                    Engine.call_.mutation sel options
                        |> Elm.withType
                            (Gen.Platform.Cmd.annotation_.cmd
                                (Gen.Result.annotation_.result
                                    Engine.annotation_.error
                                    (Type.var "data")
                                )
                            )
                )
            )
            |> Elm.exposeWith
                { exposeConstructor = True
                , group = Just groups.mutations
                }
         , Elm.declaration "queryTask"
            (Elm.fn2
                ( "sel", Just (Type.namedWith [] "Query" [ Type.var "data" ]) )
                ( "options"
                , Just
                    (Type.record
                        [ ( "headers", Type.list (Type.named [ "Http" ] "Header") )
                        , ( "url", Type.string )
                        , ( "timeout", Type.maybe Type.float )
                        ]
                    )
                )
                (\sel options ->
                    Engine.call_.queryTask sel options
                        |> Elm.withType
                            (Type.namedWith
                                [ "Task" ]
                                "Task"
                                [ Engine.annotation_.error, Type.var "data" ]
                            )
                )
            )
            |> Elm.exposeWith
                { exposeConstructor = True
                , group = Just groups.queries
                }
         , Elm.declaration "mutationTask"
            (Elm.fn2
                ( "sel", Just (Type.namedWith [] "Mutation" [ Type.var "data" ]) )
                ( "options"
                , Just
                    (Type.record
                        [ ( "headers", Type.list (Type.named [ "Http" ] "Header") )
                        , ( "url", Type.string )
                        , ( "timeout", Type.maybe Type.float )
                        ]
                    )
                )
                (\sel options ->
                    Engine.call_.mutationTask sel options
                        |> Elm.withType
                            (Type.namedWith
                                [ "Task" ]
                                "Task"
                                [ Engine.annotation_.error, Type.var "data" ]
                            )
                )
            )
            |> Elm.exposeWith
                { exposeConstructor = True
                , group = Just groups.mutations
                }
         , Elm.declaration "null"
            Engine.make_.null
            |> Elm.exposeWith
                { exposeConstructor = True
                , group = Just groups.optional
                }
         , Elm.declaration "absent"
            Engine.make_.absent
            |> Elm.exposeWith
                { exposeConstructor = True
                , group = Just groups.optional
                }
         , Elm.declaration "present"
            (Elm.fn ( "input", Just (Type.var "input") ) Engine.make_.present
                |> Elm.withType
                    (Type.function [ Type.var "input" ]
                        (Type.namedWith [] "Option" [ Type.var "input" ])
                    )
            )
            |> Elm.exposeWith
                { exposeConstructor = True
                , group = Just groups.optional
                }
         , Elm.alias "Option"
            (Engine.annotation_.option
                (Type.var "input")
            )
            |> Elm.exposeWith
                { exposeConstructor = False
                , group = Just groups.optional
                }
         , Elm.declaration "batch"
            Engine.values_.batch
            |> Elm.exposeWith
                { exposeConstructor = True
                , group = Just groups.maps
                }
         , Elm.declaration "map"
            Engine.values_.map
            |> Elm.exposeWith
                { exposeConstructor = True
                , group = Just groups.maps
                }
         , Elm.declaration "map2"
            Engine.values_.map2
            |> Elm.exposeWith
                { exposeConstructor = True
                , group = Just groups.maps
                }
         ]
            ++ Generate.Scalar.generate namespace schema
        )
