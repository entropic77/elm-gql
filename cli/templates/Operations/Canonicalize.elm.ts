export default (): string => "module GraphQL.Operations.Canonicalize exposing\n    ( Paths\n    , canonicalize\n    )\n\n{-| -}\n\nimport Dict exposing (Dict)\nimport Generate.Path\nimport GraphQL.Operations.AST as AST\nimport GraphQL.Operations.CanonicalAST as Can\nimport GraphQL.Operations.Canonicalize.Cache as Cache\nimport GraphQL.Operations.Canonicalize.Error as Error\nimport GraphQL.Schema\nimport Utils.String\n\n\ntype CanResult success\n    = CanError (List Error.Error)\n    | CanSuccess Cache.Cache success\n\n\nmapCache : (Cache.Cache -> Cache.Cache) -> CanResult success -> CanResult success\nmapCache fn result =\n    case result of\n        CanError message ->\n            CanError message\n\n        CanSuccess cache data ->\n            CanSuccess (fn cache) data\n\n\ntype alias References =\n    { schema : GraphQL.Schema.Schema\n    , fragments : Dict String Can.Fragment\n    , paths : Paths\n    }\n\n\nerr : List Error.Error -> CanResult success\nerr =\n    CanError\n\n\nsuccess : Cache.Cache -> success -> CanResult success\nsuccess =\n    CanSuccess\n\n\nok : success -> Cache.Cache -> CanResult success\nok data cache =\n    CanSuccess cache data\n\n\ntype alias Paths =\n    { path : String\n    , gqlDir : List String\n    }\n\n\ncanonicalize : GraphQL.Schema.Schema -> Paths -> AST.Document -> Result (List Error.Error) Can.Document\ncanonicalize schema paths doc =\n    let\n        fragmentResult =\n            List.foldl\n                (getFragments\n                    schema\n                )\n                (Ok Dict.empty)\n                doc.definitions\n    in\n    case fragmentResult of\n        Err fragErrorDetails ->\n            Err (List.map Error.error fragErrorDetails)\n\n        Ok fragments ->\n            let\n                startingCache =\n                    Cache.init\n                        { reservedNames =\n                            -- These are names that we know will be in the generated code\n                            [ \"Input\"\n                            , \"Response\"\n                            ]\n                        }\n\n                canonicalizedFragments =\n                    List.foldl\n                        (canonicalizeFragment schema paths)\n                        (CanSuccess startingCache Dict.empty)\n                        (List.sortBy AST.fragmentCount\n                            (Dict.values fragments)\n                        )\n            in\n            case canonicalizedFragments of\n                CanSuccess _ canonicalFrags ->\n                    let\n                        canonicalizedDefinitions =\n                            List.foldl\n                                (canonicalizeDefinition\n                                    { schema = schema\n                                    , fragments = canonicalFrags\n                                    , paths = paths\n                                    }\n                                )\n                                (CanSuccess startingCache [])\n                                doc.definitions\n                    in\n                    case canonicalizedDefinitions of\n                        CanSuccess finalCache defs ->\n                            Ok\n                                { definitions = defs\n                                , fragments = Dict.values canonicalFrags\n                                , usages = finalCache.usage\n                                }\n\n                        CanError errorMsg ->\n                            Err errorMsg\n\n                CanError errorMsg ->\n                    Err errorMsg\n\n\ngetFragments :\n    GraphQL.Schema.Schema\n    -> AST.Definition\n    -> Result (List Error.ErrorDetails) (Dict String AST.FragmentDetails)\n    -> Result (List Error.ErrorDetails) (Dict String AST.FragmentDetails)\ngetFragments schema def result =\n    case result of\n        Err errs ->\n            Err errs\n\n        Ok frags ->\n            case def of\n                AST.Operation _ ->\n                    result\n\n                AST.Fragment frag ->\n                    let\n                        name =\n                            AST.nameToString frag.name\n                    in\n                    case Dict.get name frags of\n                        Nothing ->\n                            frags\n                                |> Dict.insert\n                                    (AST.nameToString frag.name)\n                                    frag\n                                |> Ok\n\n                        Just found ->\n                            Err\n                                [ Error.FragmentDuplicateFound\n                                    { firstName = AST.nameToString frag.name\n                                    , firstTypeCondition = AST.nameToString frag.typeCondition\n                                    , firstFieldCount = List.length frag.selection\n                                    , secondName = AST.nameToString found.name\n                                    , secondTypeCondition = AST.nameToString found.typeCondition\n                                    , secondFieldCount = List.length found.selection\n                                    }\n                                ]\n\n\nconvertName : AST.Name -> Can.Name\nconvertName (AST.Name str) =\n    Can.Name str\n\n\ncanonicalizeDefinition :\n    References\n    -> AST.Definition\n    -> CanResult (List Can.Definition)\n    -> CanResult (List Can.Definition)\ncanonicalizeDefinition refs def result =\n    case result of\n        CanError message ->\n            CanError message\n\n        CanSuccess startCache cannedDefs ->\n            case def of\n                AST.Fragment _ ->\n                    CanSuccess startCache cannedDefs\n\n                AST.Operation details ->\n                    let\n                        globalOperationName =\n                            Maybe.map convertName details.name\n\n                        operationType =\n                            case details.operationType of\n                                AST.Query ->\n                                    Can.Query\n\n                                AST.Mutation ->\n                                    Can.Mutation\n\n                        initialNameCache =\n                            startCache\n                                |> Cache.getGlobalName\n                                    (globalOperationName\n                                        |> Maybe.map Can.nameToString\n                                        |> Maybe.withDefault (opTypeName operationType)\n                                    )\n\n                        fieldResult =\n                            List.foldl\n                                (\\field fieldCanResult ->\n                                    case fieldCanResult of\n                                        CanSuccess oldCache oldItems ->\n                                            let\n                                                newResult =\n                                                    canonicalizeOperation\n                                                        refs\n                                                        details.operationType\n                                                        oldCache\n                                                        field\n                                            in\n                                            case newResult of\n                                                CanError errorMessage ->\n                                                    CanError errorMessage\n\n                                                CanSuccess newCache validItem ->\n                                                    CanSuccess\n                                                        newCache\n                                                        (validItem :: oldItems)\n\n                                        CanError _ ->\n                                            fieldCanResult\n                                )\n                                (ok [] initialNameCache.used)\n                                details.fields\n                    in\n                    case fieldResult of\n                        CanSuccess fieldCache fields ->\n                            let\n                                variableSummary =\n                                    List.foldl\n                                        verifyVariables\n                                        { declared = []\n                                        , valid = []\n                                        , issues = []\n                                        , suggestions = []\n                                        }\n                                        (mergeVars fieldCache.varTypes details.variableDefinitions)\n                            in\n                            if not (List.isEmpty variableSummary.issues) then\n                                CanError\n                                    [ Error.error\n                                        (Error.VariableIssueSummary variableSummary)\n                                    ]\n\n                            else\n                                let\n                                    fragmentVariableIssues =\n                                        List.filterMap\n                                            (fragmentVariableErrors details.variableDefinitions)\n                                            (List.map .fragment fieldCache.fragmentsUsed)\n                                in\n                                if not (List.isEmpty fragmentVariableIssues) then\n                                    CanError\n                                        (List.map\n                                            (Error.error << Error.FragmentVariableIssue)\n                                            fragmentVariableIssues\n                                        )\n\n                                else\n                                    let\n                                        new =\n                                            Can.Operation\n                                                { operationType =\n                                                    operationType\n                                                , name = globalOperationName\n                                                , variableDefinitions =\n                                                    variableSummary.valid\n                                                , directives =\n                                                    List.map convertDirective details.directives\n                                                , fields = fields\n                                                , fragmentsUsed = fieldCache.fragmentsUsed\n                                                }\n                                    in\n                                    CanSuccess (Cache.finishedDefinition fieldCache)\n                                        (new :: cannedDefs)\n\n                        CanError errorMsg ->\n                            CanError errorMsg\n\n\nfragmentVariableErrors : List AST.VariableDefinition -> Can.Fragment -> Maybe Error.FragmentVariableSummary\nfragmentVariableErrors varDefs frag =\n    let\n        varSummary =\n            { fragmentName = Can.nameToString frag.name\n            , declared =\n                List.map\n                    (\\def ->\n                        { name = AST.nameToString def.variable.name\n                        , type_ = AST.typeToGqlString def.type_\n                        }\n                    )\n                    varDefs\n            , used =\n                List.map\n                    (\\( name, varType ) ->\n                        { name = name\n                        , type_ = GraphQL.Schema.typeToString varType\n                        }\n                    )\n                    frag.usedVariables\n            }\n\n        variableIssue ( name, varType ) existingIssue =\n            case existingIssue of\n                Just _ ->\n                    existingIssue\n\n                _ ->\n                    case List.head (List.filter (\\def -> AST.nameToString def.variable.name == name) varDefs) of\n                        Nothing ->\n                            Just varSummary\n\n                        Just found ->\n                            if String.toLower (AST.typeToGqlString found.type_) == String.toLower (GraphQL.Schema.typeToString varType) then\n                                Nothing\n\n                            else\n                                Just varSummary\n    in\n    List.foldl variableIssue Nothing frag.usedVariables\n\n\nopTypeName : Can.OperationType -> String\nopTypeName op =\n    case op of\n        Can.Query ->\n            \"Query\"\n\n        Can.Mutation ->\n            \"Mutation\"\n\n\n{-| The AST.Type is the type declared at the top of the document.\n\nThe Schema.Type is what is in the schema.\n\n    variableDefinition is the AST representation of the variable declaration at the top.\n\n-}\ndoTypesMatch : GraphQL.Schema.Type -> AST.Type -> Bool\ndoTypesMatch schemaType variableDefinition =\n    case variableDefinition of\n        AST.Type_ astName ->\n            case schemaType of\n                GraphQL.Schema.Scalar schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.InputObject schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.Object schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.Enum schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.Union schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.Interface schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.List_ _ ->\n                    False\n\n                GraphQL.Schema.Nullable innerSchema ->\n                    -- the query can mark something as required even if it's optional in the schema\n                    doTypesMatch innerSchema variableDefinition\n\n        AST.Nullable innerAST ->\n            case schemaType of\n                GraphQL.Schema.Nullable innerSchema ->\n                    doTypesMatch innerSchema innerAST\n\n                _ ->\n                    False\n\n        AST.List_ innerAST ->\n            case schemaType of\n                GraphQL.Schema.List_ innerSchema ->\n                    doTypesMatch innerSchema innerAST\n\n                GraphQL.Schema.Nullable innerSchema ->\n                    -- the query can mark something as required even if it's optional in the schema\n                    doTypesMatch innerSchema variableDefinition\n\n                _ ->\n                    False\n\n\nverifyVariables :\n    { name : String\n    , definition : Maybe AST.VariableDefinition\n    , inOperation : Maybe GraphQL.Schema.Type\n    }\n    -> Error.VariableSummary\n    -> Error.VariableSummary\nverifyVariables item summary =\n    case ( item.definition, item.inOperation ) of\n        ( Just def, Just inOp ) ->\n            -- check to make sure the variables are unifiable\n            let\n                valid =\n                    { variable = { name = convertName def.variable.name }\n                    , type_ = def.type_\n                    , defaultValue = def.defaultValue\n                    , schemaType = inOp\n                    }\n\n                typeString =\n                    GraphQL.Schema.typeToString inOp\n\n                declared =\n                    { name = AST.nameToString def.variable.name\n                    , type_ =\n                        Just\n                            (AST.typeToGqlString def.type_)\n                    }\n\n                typesMatch =\n                    doTypesMatch inOp def.type_\n            in\n            { declared = declared :: summary.declared\n            , valid = valid :: summary.valid\n            , issues =\n                if typesMatch then\n                    summary.issues\n\n                else\n                    Error.UnexpectedType\n                        { name = item.name\n                        , found = Just (AST.typeToGqlString def.type_)\n                        , expected = typeString\n                        }\n                        :: summary.issues\n            , suggestions =\n                if typesMatch then\n                    -- we do this so that when we print an error message\n                    -- If the user has specified that this is a required value\n                    -- but the schema says it's optional\n                    -- we maintain the required-ness\n                    { name = AST.nameToString def.variable.name\n                    , type_ =\n                        AST.typeToGqlString def.type_\n                    }\n                        :: summary.suggestions\n\n                else\n                    let\n                        suggestion =\n                            { name = AST.nameToString def.variable.name\n                            , type_ = typeString\n                            }\n                    in\n                    suggestion :: summary.suggestions\n            }\n\n        ( Just def, Nothing ) ->\n            { declared =\n                { name = AST.nameToString def.variable.name\n                , type_ = Nothing\n                }\n                    :: summary.declared\n            , valid = summary.valid\n            , issues =\n                Error.Unused\n                    { name = item.name\n                    , possibly = []\n                    }\n                    :: summary.issues\n            , suggestions =\n                summary.suggestions\n            }\n\n        ( Nothing, Just inOp ) ->\n            let\n                suggestion =\n                    { name = item.name\n                    , type_ = GraphQL.Schema.typeToString inOp\n                    }\n            in\n            { declared = summary.declared\n            , valid = summary.valid\n            , issues =\n                Error.Undeclared\n                    { name = item.name\n                    , possibly = []\n                    }\n                    :: summary.issues\n            , suggestions = suggestion :: summary.suggestions\n            }\n\n        ( Nothing, Nothing ) ->\n            summary\n\n\nmergeVars :\n    List ( String, GraphQL.Schema.Type )\n    -> List AST.VariableDefinition\n    ->\n        List\n            { name : String\n            , definition : Maybe AST.VariableDefinition\n            , inOperation : Maybe GraphQL.Schema.Type\n            }\nmergeVars varTypes variableDefinitions =\n    let\n        allNames =\n            List.foldl\n                (\\varName found ->\n                    if List.member varName found then\n                        found\n\n                    else\n                        varName :: found\n                )\n                []\n                (List.map (.variable >> .name >> AST.nameToString) variableDefinitions\n                    ++ List.map Tuple.first varTypes\n                )\n                |> List.reverse\n    in\n    List.map\n        (\\name ->\n            { name = name\n            , definition =\n                List.foldl\n                    (\\def found ->\n                        case found of\n                            Nothing ->\n                                if AST.nameToString def.variable.name == name then\n                                    Just def\n\n                                else\n                                    found\n\n                            _ ->\n                                found\n                    )\n                    Nothing\n                    variableDefinitions\n            , inOperation =\n                find name varTypes\n            }\n        )\n        allNames\n\n\nfind : String -> List ( String, a ) -> Maybe a\nfind str items =\n    case items of\n        [] ->\n            Nothing\n\n        ( key, val ) :: remain ->\n            if str == key then\n                Just val\n\n            else\n                find str remain\n\n\ncanonicalizeOperation :\n    References\n    -> AST.OperationType\n    -> Cache.Cache\n    -> AST.Selection\n    -> CanResult Can.Field\ncanonicalizeOperation refs op cache selection =\n    case selection of\n        AST.Field field ->\n            let\n                matched =\n                    case op of\n                        AST.Query ->\n                            Dict.get (AST.nameToString field.name) refs.schema.queries\n\n                        AST.Mutation ->\n                            Dict.get (AST.nameToString field.name) refs.schema.mutations\n            in\n            case matched of\n                Nothing ->\n                    err [ Error.error (Error.QueryUnknown (AST.nameToString field.name)) ]\n\n                Just query ->\n                    canonicalizeFieldType refs\n                        field\n                        (cache\n                            |> (case op of\n                                    AST.Query ->\n                                        Cache.query (AST.nameToString field.name) refs.paths.path\n\n                                    AST.Mutation ->\n                                        Cache.mutation (AST.nameToString field.name) refs.paths.path\n                               )\n                        )\n                        query\n                        |> mapCache Cache.dropLevel\n\n        AST.FragmentSpreadSelection _ ->\n            err [ Error.todo \"Top level Fragments aren't suported yet!\" ]\n\n        AST.InlineFragmentSelection inline ->\n            -- This is when we're selecting a union fragment\n            err [ Error.error (Error.FragmentInlineTopLevel { fragment = inline }) ]\n\n\ntype InputValidation\n    = Valid (List ( String, GraphQL.Schema.Type ))\n    | Mismatch\n\n\nvalidateInput :\n    References\n    -> GraphQL.Schema.Type\n    -> String\n    -> AST.Value\n    -> InputValidation\nvalidateInput refs schemaType fieldName astValue =\n    case astValue of\n        AST.Var var ->\n            let\n                varname =\n                    AST.nameToString var.name\n            in\n            Valid [ ( varname, schemaType ) ]\n\n        AST.Object keyValues ->\n            case schemaType of\n                GraphQL.Schema.InputObject inputObjectName ->\n                    case Dict.get inputObjectName refs.schema.inputObjects of\n                        Nothing ->\n                            Mismatch\n\n                        Just inputObject ->\n                            validateObject refs fieldName keyValues inputObject\n\n                GraphQL.Schema.Nullable (GraphQL.Schema.InputObject inputObjectName) ->\n                    case Dict.get inputObjectName refs.schema.inputObjects of\n                        Nothing ->\n                            Mismatch\n\n                        Just inputObject ->\n                            validateObject refs fieldName keyValues inputObject\n\n                GraphQL.Schema.List_ inner ->\n                    -- A single literal can be coerced into a list\n                    -- https://spec.graphql.org/June2018/#sec-Type-System.List\n                    validateInput refs inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.Str _ ->\n            case schemaType of\n                GraphQL.Schema.Scalar \"Int\" ->\n                    Mismatch\n\n                GraphQL.Schema.Scalar \"Float\" ->\n                    Mismatch\n\n                GraphQL.Schema.Scalar \"Boolean\" ->\n                    Mismatch\n\n                GraphQL.Schema.Scalar _ ->\n                    Valid []\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput refs inner fieldName astValue\n\n                GraphQL.Schema.List_ inner ->\n                    -- A single literal can be coerced into a list\n                    -- https://spec.graphql.org/June2018/#sec-Type-System.List\n                    validateInput refs inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.Integer _ ->\n            case schemaType of\n                GraphQL.Schema.Scalar \"Int\" ->\n                    Valid []\n\n                GraphQL.Schema.Scalar \"Float\" ->\n                    Valid []\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput refs inner fieldName astValue\n\n                GraphQL.Schema.List_ inner ->\n                    -- A single literal can be coerced into a list\n                    -- https://spec.graphql.org/June2018/#sec-Type-System.List\n                    validateInput refs inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.Decimal _ ->\n            case schemaType of\n                GraphQL.Schema.Scalar \"Float\" ->\n                    Valid []\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput refs inner fieldName astValue\n\n                GraphQL.Schema.List_ inner ->\n                    -- A single literal can be coerced into a list\n                    -- https://spec.graphql.org/June2018/#sec-Type-System.List\n                    validateInput refs inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.Boolean _ ->\n            case schemaType of\n                GraphQL.Schema.Scalar \"Boolean\" ->\n                    Valid []\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput refs inner fieldName astValue\n\n                GraphQL.Schema.List_ inner ->\n                    -- A single literal can be coerced into a list\n                    -- https://spec.graphql.org/June2018/#sec-Type-System.List\n                    validateInput refs inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.Null ->\n            case schemaType of\n                GraphQL.Schema.Nullable _ ->\n                    Valid []\n\n                _ ->\n                    Mismatch\n\n        AST.Enum _ ->\n            case schemaType of\n                GraphQL.Schema.Enum _ ->\n                    Valid []\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput refs inner fieldName astValue\n\n                GraphQL.Schema.List_ inner ->\n                    -- A single literal can be coerced into a list\n                    -- https://spec.graphql.org/June2018/#sec-Type-System.List\n                    validateInput refs inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.ListValue list ->\n            case schemaType of\n                GraphQL.Schema.List_ innerList ->\n                    List.foldl\n                        (\\item current ->\n                            case current of\n                                Valid validArgs ->\n                                    case validateInput refs innerList fieldName item of\n                                        Valid newArgs ->\n                                            Valid (newArgs ++ validArgs)\n\n                                        validationError ->\n                                            validationError\n\n                                _ ->\n                                    current\n                        )\n                        (Valid [])\n                        list\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput refs inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n\nvalidateObject refs fieldName keyValues inputObject =\n    List.foldl\n        (\\( keyName, value ) current ->\n            case current of\n                Valid argValues ->\n                    let\n                        key =\n                            AST.nameToString keyName\n                    in\n                    case List.head (List.filter (\\a -> a.name == key) inputObject.fields) of\n                        Nothing ->\n                            Mismatch\n\n                        Just field ->\n                            case validateInput refs field.type_ fieldName value of\n                                Valid fieldArgs ->\n                                    Valid (argValues ++ fieldArgs)\n\n                                validationError ->\n                                    validationError\n\n                _ ->\n                    current\n        )\n        (Valid [])\n        keyValues\n\n\nselectsSingleFragment :\n    References\n    -> List AST.Selection\n    ->\n        Maybe\n            { importFrom : List String\n            , importMockFrom : List String\n            , name : String\n            }\nselectsSingleFragment refs fields =\n    case fields of\n        [ AST.FragmentSpreadSelection fragment ] ->\n            let\n                fragName =\n                    Utils.String.formatTypename (AST.nameToString fragment.name)\n\n                paths =\n                    Generate.Path.fragment\n                        { name = fragName\n                        , path = refs.paths.path\n                        , gqlDir = refs.paths.gqlDir\n                        }\n            in\n            Just\n                { importFrom = paths.modulePath\n                , importMockFrom = paths.mockModulePath\n                , name = fragName\n                }\n\n        _ ->\n            Nothing\n\n\ncanonicalizeFragment :\n    GraphQL.Schema.Schema\n    -> Paths\n    -> AST.FragmentDetails\n    -> CanResult (Dict String Can.Fragment)\n    -> CanResult (Dict String Can.Fragment)\ncanonicalizeFragment schema paths frag currentResult =\n    case currentResult of\n        CanError errMsg ->\n            CanError errMsg\n\n        CanSuccess cache existingFrags ->\n            let\n                fragName =\n                    AST.nameToString frag.name\n\n                fragPaths =\n                    Generate.Path.fragment\n                        { name = fragName\n                        , path = paths.path\n                        , gqlDir = paths.gqlDir\n                        }\n\n                typeCondition =\n                    AST.nameToString frag.typeCondition\n            in\n            case Dict.get typeCondition schema.objects of\n                Just obj ->\n                    let\n                        selectionResult =\n                            List.foldl\n                                (canonicalizeField\n                                    { schema = schema\n                                    , fragments = existingFrags\n                                    , paths = paths\n                                    }\n                                    obj\n                                )\n                                (cache\n                                    |> Cache.addLevel\n                                        { name = AST.nameToString frag.name\n                                        , isAlias = False\n                                        }\n                                    |> ok []\n                                )\n                                frag.selection\n                    in\n                    case selectionResult of\n                        CanSuccess fragmentSpecificCache selection ->\n                            CanSuccess fragmentSpecificCache\n                                (existingFrags\n                                    |> Dict.insert fragName\n                                        { name = convertName frag.name\n                                        , importFrom = fragPaths.modulePath\n                                        , typeCondition = convertName frag.typeCondition\n                                        , usedVariables = fragmentSpecificCache.varTypes\n                                        , fragmentsUsed =\n                                            List.map (.fragment >> .name) fragmentSpecificCache.fragmentsUsed\n                                        , directives = List.map convertDirective frag.directives\n                                        , selection =\n                                            Can.FragmentObject\n                                                { selection = selection }\n                                        }\n                                )\n\n                        CanError errorMsg ->\n                            CanError errorMsg\n\n                Nothing ->\n                    case Dict.get typeCondition schema.interfaces of\n                        Just interface ->\n                            let\n                                variants =\n                                    List.foldl getInterfaceNames [] interface.implementedBy\n\n                                canVarSelectionResult =\n                                    canonicalizeVariantSelection\n                                        { schema = schema\n                                        , fragments = existingFrags\n                                        , paths = paths\n                                        }\n                                        (cache\n                                            |> Cache.addLevel\n                                                { name = AST.nameToString frag.name\n                                                , isAlias = False\n                                                }\n                                        )\n                                        { name = interface.name\n                                        , description = interface.description\n                                        , fields = interface.fields\n                                        }\n                                        frag.selection\n                                        variants\n                            in\n                            case canVarSelectionResult of\n                                CanSuccess fragmentSpecificCache selection ->\n                                    CanSuccess fragmentSpecificCache\n                                        (existingFrags\n                                            |> Dict.insert (AST.nameToString frag.name)\n                                                { name = convertName frag.name\n                                                , importFrom = fragPaths.modulePath\n                                                , typeCondition = convertName frag.typeCondition\n                                                , usedVariables = fragmentSpecificCache.varTypes\n                                                , fragmentsUsed = List.map (.fragment >> .name) fragmentSpecificCache.fragmentsUsed\n                                                , directives = List.map convertDirective frag.directives\n                                                , selection =\n                                                    Can.FragmentInterface selection\n                                                }\n                                        )\n\n                                CanError errorMsg ->\n                                    CanError errorMsg\n\n                        Nothing ->\n                            case Dict.get typeCondition schema.unions of\n                                Just union ->\n                                    let\n                                        variants =\n                                            Maybe.withDefault [] <| extractUnionTags union.variants []\n\n                                        canVarSelectionResult =\n                                            canonicalizeVariantSelection\n                                                { schema = schema\n                                                , fragments = existingFrags\n                                                , paths = paths\n                                                }\n                                                (cache\n                                                    |> Cache.addLevel\n                                                        { name = AST.nameToString frag.name\n                                                        , isAlias = False\n                                                        }\n                                                )\n                                                { name = union.name\n                                                , description = union.description\n                                                , fields = []\n                                                }\n                                                frag.selection\n                                                variants\n                                    in\n                                    case canVarSelectionResult of\n                                        CanSuccess fragmentSpecificCache selection ->\n                                            CanSuccess fragmentSpecificCache\n                                                (existingFrags\n                                                    |> Dict.insert (AST.nameToString frag.name)\n                                                        { name = convertName frag.name\n                                                        , importFrom = fragPaths.modulePath\n                                                        , typeCondition = convertName frag.typeCondition\n                                                        , usedVariables = fragmentSpecificCache.varTypes\n                                                        , fragmentsUsed =\n                                                            List.map (.fragment >> .name) fragmentSpecificCache.fragmentsUsed\n                                                        , directives = List.map convertDirective frag.directives\n                                                        , selection =\n                                                            Can.FragmentUnion selection\n                                                        }\n                                                )\n\n                                        CanError errorMsg ->\n                                            CanError errorMsg\n\n                                Nothing ->\n                                    CanError\n                                        [ Error.error <|\n                                            Error.FragmentTargetDoesntExist\n                                                { fragmentName = AST.nameToString frag.name\n                                                , typeCondition = AST.nameToString frag.typeCondition\n                                                }\n                                        ]\n\n\ncanonicalizeVariantSelection :\n    References\n    -> Cache.Cache\n    ->\n        { description : Maybe String\n        , fields :\n            List GraphQL.Schema.Field\n        , name : String\n        }\n    -> List AST.Selection\n    -> List String\n    ->\n        CanResult\n            { remainingTags : List { globalAlias : Can.Name, tag : Can.Name }\n            , selection : List Can.Field\n            , variants : List Can.VariantCase\n            }\ncanonicalizeVariantSelection refs cache unionOrInterface selection variants =\n    let\n        selectsForTypename =\n            List.any\n                (\\sel ->\n                    case sel of\n                        AST.Field firstField ->\n                            case AST.nameToString firstField.name of\n                                \"__typename\" ->\n                                    True\n\n                                _ ->\n                                    False\n\n                        _ ->\n                            False\n                )\n                selection\n\n        selectionResult =\n            List.foldl\n                (canonicalizeFieldWithVariants refs\n                    unionOrInterface\n                )\n                { result =\n                    cache\n                        |> ok []\n                , capturedVariants = []\n                , variants = variants\n                , typenameAlreadySelected = selectsForTypename\n                }\n                selection\n    in\n    case selectionResult.result of\n        CanSuccess selectionCache canSelection ->\n            let\n                ( finalCache, remaining ) =\n                    List.foldl\n                        gatherRemaining\n                        ( selectionCache\n                        , []\n                        )\n                        selectionResult.variants\n            in\n            CanSuccess\n                (finalCache\n                    |> Cache.dropLevel\n                )\n                { selection = canSelection\n                , variants = selectionResult.capturedVariants\n                , remainingTags =\n                    List.reverse remaining\n                }\n\n        CanError errorMsg ->\n            CanError errorMsg\n\n\n{-| -}\ncanonicalizeField :\n    References\n    ->\n        { obj\n            | name : String\n            , description : Maybe String\n            , fields : List GraphQL.Schema.Field\n        }\n    -> AST.Selection\n    -> CanResult (List Can.Field)\n    -> CanResult (List Can.Field)\ncanonicalizeField refs object selection existingFieldResult =\n    case existingFieldResult of\n        CanError message ->\n            CanError message\n\n        CanSuccess cache existingFields ->\n            case selection of\n                AST.Field field ->\n                    let\n                        fieldName =\n                            AST.nameToString field.name\n                    in\n                    if fieldName == \"__typename\" then\n                        let\n                            new =\n                                Can.Field\n                                    { alias_ = Maybe.map convertName field.alias_\n                                    , name = convertName field.name\n                                    , globalAlias =\n                                        field.alias_\n                                            |> Maybe.withDefault field.name\n                                            |> convertName\n                                    , selectsOnlyFragment = Nothing\n                                    , arguments = []\n                                    , directives = List.map convertDirective field.directives\n                                    , wrapper = GraphQL.Schema.UnwrappedValue\n                                    , selection =\n                                        Can.FieldScalar (GraphQL.Schema.Scalar \"typename\")\n                                    }\n                        in\n                        cache\n                            |> ok (new :: existingFields)\n\n                    else\n                        let\n                            matchedField =\n                                object.fields\n                                    |> List.filter (\\fld -> fld.name == fieldName)\n                                    |> List.head\n                        in\n                        case matchedField of\n                            Just matched ->\n                                let\n                                    aliased =\n                                        AST.getAliasedName field\n\n                                    canonicalizedNewField =\n                                        canonicalizeFieldType refs\n                                            field\n                                            cache\n                                            matched\n\n                                    siblingID =\n                                        { aliasedName = aliased\n                                        , scalar =\n                                            if GraphQL.Schema.isScalar matched.type_ then\n                                                Just (GraphQL.Schema.typeToString matched.type_)\n\n                                            else\n                                                Nothing\n                                        }\n                                in\n                                case canonicalizedNewField of\n                                    CanSuccess newCache new ->\n                                        if Cache.siblingCollision siblingID newCache then\n                                            -- There has been a collision, abort!\n                                            err\n                                                [ Error.error\n                                                    (Error.FieldAliasRequired\n                                                        { fieldName = aliased\n                                                        }\n                                                    )\n                                                ]\n\n                                        else\n                                            newCache\n                                                |> Cache.saveSibling siblingID\n                                                |> Cache.field object.name fieldName refs.paths.path\n                                                |> ok (new :: existingFields)\n\n                                    CanError message ->\n                                        CanError message\n\n                            Nothing ->\n                                err\n                                    [ Error.error\n                                        (Error.FieldUnknown\n                                            { object = object.name\n                                            , field = fieldName\n                                            }\n                                        )\n                                    ]\n\n                AST.FragmentSpreadSelection frag ->\n                    let\n                        fragName =\n                            AST.nameToString frag.name\n                    in\n                    case Dict.get fragName refs.fragments of\n                        Nothing ->\n                            err\n                                [ Error.error <|\n                                    Error.FragmentNotFound\n                                        { found = fragName\n                                        , object = object.name\n                                        , options =\n                                            Dict.values refs.fragments\n                                        }\n                                ]\n\n                        Just foundFrag ->\n                            if Can.nameToString foundFrag.typeCondition == object.name then\n                                let\n                                    new =\n                                        Can.Frag\n                                            { fragment = foundFrag\n                                            , directives =\n                                                frag.directives\n                                                    |> List.map\n                                                        convertDirective\n                                            }\n                                in\n                                cache\n                                    |> Cache.addFragment\n                                        { fragment = foundFrag\n                                        , alongsideOtherFields = False\n                                        }\n                                    |> ok (new :: existingFields)\n\n                            else\n                                err\n                                    [ Error.error <|\n                                        Error.FragmentNotFound\n                                            { found = fragName\n                                            , object = object.name\n                                            , options =\n                                                Dict.values refs.fragments\n                                            }\n                                    ]\n\n                AST.InlineFragmentSelection inline ->\n                    err\n                        [ Error.error\n                            (Error.FragmentSelectionNotAllowedInObjects\n                                { fragment = inline\n                                , objectName = object.name\n                                }\n                            )\n                        ]\n\n\nconvertDirective dir =\n    { name = convertName dir.name\n    , arguments =\n        dir.arguments\n    }\n\n\ncanonicalizeFieldType :\n    References\n    -> AST.FieldDetails\n    -> Cache.Cache\n    -> GraphQL.Schema.Field\n    -> CanResult Can.Field\ncanonicalizeFieldType refs field cache schemaField =\n    canonicalizeFieldTypeHelper refs field schemaField.type_ cache schemaField\n\n\ncanonicalizeArguments :\n    References\n    -> List GraphQL.Schema.Argument\n    -> List AST.Argument\n    ->\n        { valid : List ( String, GraphQL.Schema.Type )\n        , unknown : List String\n        , errs : List Error.Error\n        }\ncanonicalizeArguments refs schemaArguments arguments =\n    List.foldl\n        (\\arg found ->\n            let\n                fieldname =\n                    AST.nameToString arg.name\n            in\n            case List.head (List.filter (\\a -> a.name == fieldname) schemaArguments) of\n                Nothing ->\n                    { found\n                        | unknown =\n                            fieldname :: found.unknown\n                    }\n\n                Just schemaVar ->\n                    case validateInput refs schemaVar.type_ fieldname arg.value of\n                        Valid vars ->\n                            { found\n                                | valid =\n                                    vars ++ found.valid\n                            }\n\n                        Mismatch ->\n                            { found\n                                | errs =\n                                    Error.error\n                                        (Error.IncorrectInlineInput\n                                            { schema = schemaVar.type_\n                                            , arg = fieldname\n                                            , found = arg.value\n                                            }\n                                        )\n                                        :: found.errs\n                            }\n        )\n        { valid = []\n        , unknown = []\n        , errs = []\n        }\n        arguments\n\n\n{-|\n\n    For `field`, we are matching it up with types from `schema`\n\n-}\ncanonicalizeFieldTypeHelper :\n    References\n    -> AST.FieldDetails\n    -> GraphQL.Schema.Type\n    -> Cache.Cache\n    -> GraphQL.Schema.Field\n    -> CanResult Can.Field\ncanonicalizeFieldTypeHelper refs field type_ initialVarCache schemaField =\n    let\n        argValidation =\n            canonicalizeArguments refs schemaField.arguments field.arguments\n    in\n    if not (List.isEmpty argValidation.unknown) then\n        CanError\n            [ Error.error <|\n                Error.UnknownArgs\n                    { field = AST.nameToString field.name\n                    , unknownArgs = argValidation.unknown\n                    , allowedArgs =\n                        schemaField.arguments\n                    }\n            ]\n\n    else if not (List.isEmpty argValidation.errs) then\n        CanError argValidation.errs\n\n    else\n        let\n            vars =\n                List.reverse argValidation.valid\n\n            newCache =\n                initialVarCache |> Cache.addVars vars\n        in\n        case type_ of\n            GraphQL.Schema.Scalar scalarName ->\n                newCache\n                    |> Cache.scalar scalarName refs.paths.path\n                    |> ok\n                        (Can.Field\n                            { alias_ = Maybe.map convertName field.alias_\n                            , name = convertName field.name\n                            , selectsOnlyFragment = Nothing\n                            , globalAlias =\n                                field.alias_\n                                    |> Maybe.withDefault field.name\n                                    |> convertName\n                            , arguments = field.arguments\n                            , directives = List.map convertDirective field.directives\n                            , wrapper = GraphQL.Schema.getWrap schemaField.type_\n                            , selection =\n                                Can.FieldScalar (GraphQL.Schema.getInner schemaField.type_)\n                            }\n                        )\n\n            GraphQL.Schema.InputObject _ ->\n                err [ Error.todo \"Invalid schema!  Weird InputObject\" ]\n\n            GraphQL.Schema.Object name ->\n                case Dict.get name refs.schema.objects of\n                    Nothing ->\n                        err [ Error.error (Error.ObjectUnknown name) ]\n\n                    Just obj ->\n                        canonicalizeObject refs\n                            field\n                            schemaField\n                            newCache\n                            obj\n\n            GraphQL.Schema.Enum enumName ->\n                case Dict.get enumName refs.schema.enums of\n                    Nothing ->\n                        err [ Error.error (Error.EnumUnknown enumName) ]\n\n                    Just enum ->\n                        newCache\n                            |> Cache.enum enumName refs.paths.path\n                            |> ok\n                                (Can.Field\n                                    { alias_ = Maybe.map convertName field.alias_\n                                    , name = convertName field.name\n                                    , globalAlias =\n                                        field.alias_\n                                            |> Maybe.withDefault field.name\n                                            |> convertName\n                                    , selectsOnlyFragment = Nothing\n                                    , arguments = field.arguments\n                                    , directives = List.map convertDirective field.directives\n                                    , wrapper = GraphQL.Schema.getWrap schemaField.type_\n                                    , selection =\n                                        Can.FieldEnum\n                                            { enumName = enum.name\n                                            , values = enum.values\n                                            }\n                                    }\n                                )\n\n            GraphQL.Schema.Union name ->\n                case Dict.get name refs.schema.unions of\n                    Nothing ->\n                        err [ Error.error (Error.UnionUnknown name) ]\n\n                    Just union ->\n                        case extractUnionTags union.variants [] of\n                            Nothing ->\n                                err [ Error.todo \"Things in a union are not objects!\" ]\n\n                            Just variants ->\n                                let\n                                    aliasedName =\n                                        field.alias_\n                                            |> Maybe.withDefault field.name\n                                            |> convertName\n                                            |> Can.nameToString\n\n                                    global =\n                                        Cache.getGlobalName aliasedName newCache\n\n                                    canVarSelectionResult =\n                                        canonicalizeVariantSelection refs\n                                            (global.used\n                                                |> Cache.addLevel (Cache.levelFromField field)\n                                            )\n                                            { name = union.name\n                                            , description = union.description\n\n                                            -- Note, unions dont have any fields themselves, unlike interfaces\n                                            , fields = []\n                                            }\n                                            field.selection\n                                            variants\n                                in\n                                case canVarSelectionResult of\n                                    CanSuccess cache variantSelection ->\n                                        CanSuccess cache\n                                            (Can.Field\n                                                { alias_ = Maybe.map convertName field.alias_\n                                                , name = convertName field.name\n                                                , globalAlias = Can.Name global.globalName\n                                                , selectsOnlyFragment = selectsSingleFragment refs field.selection\n                                                , arguments = field.arguments\n                                                , directives = List.map convertDirective field.directives\n                                                , wrapper = GraphQL.Schema.getWrap schemaField.type_\n                                                , selection =\n                                                    Can.FieldUnion variantSelection\n                                                }\n                                            )\n\n                                    CanError errorMsg ->\n                                        CanError errorMsg\n\n            GraphQL.Schema.Interface name ->\n                case Dict.get name refs.schema.interfaces of\n                    Nothing ->\n                        err [ Error.error (Error.UnionUnknown name) ]\n\n                    Just interface ->\n                        let\n                            variants =\n                                List.foldl getInterfaceNames [] interface.implementedBy\n\n                            aliasedName =\n                                field.alias_\n                                    |> Maybe.withDefault field.name\n                                    |> convertName\n                                    |> Can.nameToString\n\n                            global =\n                                Cache.getGlobalName aliasedName newCache\n\n                            canVarSelectionResult =\n                                canonicalizeVariantSelection refs\n                                    (global.used\n                                        |> Cache.addLevel (Cache.levelFromField field)\n                                    )\n                                    { name = interface.name\n                                    , description = interface.description\n                                    , fields = interface.fields\n                                    }\n                                    field.selection\n                                    variants\n                        in\n                        case canVarSelectionResult of\n                            CanSuccess cache variantSelection ->\n                                CanSuccess cache\n                                    (Can.Field\n                                        { alias_ = Maybe.map convertName field.alias_\n                                        , name = convertName field.name\n                                        , globalAlias =\n                                            Can.Name global.globalName\n                                        , selectsOnlyFragment = selectsSingleFragment refs field.selection\n                                        , arguments = field.arguments\n                                        , directives = List.map convertDirective field.directives\n                                        , wrapper = GraphQL.Schema.getWrap schemaField.type_\n                                        , selection =\n                                            Can.FieldInterface variantSelection\n                                        }\n                                    )\n\n                            CanError errorMsg ->\n                                CanError errorMsg\n\n            GraphQL.Schema.List_ inner ->\n                canonicalizeFieldTypeHelper refs field inner newCache schemaField\n\n            GraphQL.Schema.Nullable inner ->\n                canonicalizeFieldTypeHelper refs field inner newCache schemaField\n\n\ngatherRemaining :\n    String\n    ->\n        ( Cache.Cache\n        , List\n            { globalAlias : Can.Name\n            , tag : Can.Name\n            }\n        )\n    ->\n        ( Cache.Cache\n        , List\n            { globalAlias : Can.Name\n            , tag : Can.Name\n            }\n        )\ngatherRemaining tag ( used, gathered ) =\n    let\n        global =\n            Cache.getGlobalName tag used\n    in\n    ( global.used\n    , { globalAlias = Can.Name global.globalName\n      , tag = Can.Name tag\n      }\n        :: gathered\n    )\n\n\ncanonicalizeObject :\n    References\n    -> AST.FieldDetails\n    -> GraphQL.Schema.Field\n    -> Cache.Cache\n    -> GraphQL.Schema.ObjectDetails\n    -> CanResult Can.Field\ncanonicalizeObject refs field schemaField varCache obj =\n    case field.selection of\n        [] ->\n            -- This is an object with no selection, which isn't allowed for gql.\n            err\n                [ Error.error\n                    (Error.EmptySelection\n                        { field =\n                            case field.alias_ of\n                                Nothing ->\n                                    AST.nameToString field.name\n\n                                Just alias ->\n                                    AST.nameToString alias\n                                        ++ \": \"\n                                        ++ AST.nameToString field.name\n                        , fieldType = obj.name\n                        , options =\n                            List.map\n                                (\\f ->\n                                    { field = f.name\n                                    , type_ = GraphQL.Schema.typeToString f.type_\n                                    }\n                                )\n                                obj.fields\n                        }\n                    )\n                ]\n\n        _ ->\n            let\n                aliasedName =\n                    field.alias_\n                        |> Maybe.withDefault field.name\n                        |> convertName\n                        |> Can.nameToString\n\n                global =\n                    Cache.getGlobalName aliasedName varCache\n\n                selectionResult =\n                    List.foldl\n                        (canonicalizeField refs obj)\n                        (global.used\n                            |> Cache.addLevel (Cache.levelFromField field)\n                            |> ok []\n                        )\n                        field.selection\n            in\n            case selectionResult of\n                CanSuccess cache canSelection ->\n                    let\n                        siblingID =\n                            { aliasedName = aliasedName\n\n                            -- This is an object, not a scalar\n                            , scalar = Nothing\n                            }\n                    in\n                    if Cache.siblingCollision siblingID global.used then\n                        err\n                            [ Error.error\n                                (Error.FieldAliasRequired\n                                    { fieldName = aliasedName\n                                    }\n                                )\n                            ]\n\n                    else\n                        CanSuccess\n                            (cache\n                                |> Cache.dropLevel\n                            )\n                            (Can.Field\n                                { alias_ = Maybe.map convertName field.alias_\n                                , name = convertName field.name\n                                , globalAlias = Can.Name global.globalName\n                                , selectsOnlyFragment = selectsSingleFragment refs field.selection\n                                , arguments = field.arguments\n                                , directives = List.map convertDirective field.directives\n                                , wrapper = GraphQL.Schema.getWrap schemaField.type_\n                                , selection =\n                                    Can.FieldObject canSelection\n                                }\n                            )\n\n                CanError errorMsg ->\n                    CanError errorMsg\n\n\ngetInterfaceNames kind found =\n    case kind of\n        GraphQL.Schema.ObjectKind name ->\n            name :: found\n\n        _ ->\n            found\n\n\n{-| Members of a union can only be objects:\n<https://spec.graphql.org/June2018/#sec-Unions>\n\nSome more details: <https://github.com/graphql/graphql-js/issues/451>\n\n-}\nextractUnionTags : List GraphQL.Schema.Variant -> List String -> Maybe (List String)\nextractUnionTags vars captured =\n    case vars of\n        [] ->\n            Just captured\n\n        top :: remain ->\n            case top.kind of\n                GraphQL.Schema.ObjectKind name ->\n                    extractUnionTags remain (name :: captured)\n\n                _ ->\n                    Nothing\n\n\ncanonicalizeFieldWithVariants :\n    References\n    ->\n        { obj\n            | name : String\n            , description : Maybe String\n            , fields : List GraphQL.Schema.Field\n        }\n    -> AST.Selection\n    ->\n        { result : CanResult (List Can.Field)\n        , variants : List String\n        , capturedVariants : List Can.VariantCase\n        , typenameAlreadySelected : Bool\n        }\n    ->\n        { result : CanResult (List Can.Field)\n        , variants : List String\n        , capturedVariants : List Can.VariantCase\n        , typenameAlreadySelected : Bool\n        }\ncanonicalizeFieldWithVariants refs unionOrInterface selection found =\n    case found.result of\n        CanError message ->\n            found\n\n        CanSuccess cache existingFields ->\n            case selection of\n                AST.Field field ->\n                    let\n                        fieldName =\n                            AST.nameToString field.name\n                    in\n                    if fieldName == \"__typename\" then\n                        let\n                            new =\n                                Can.Field\n                                    { alias_ = Maybe.map convertName field.alias_\n                                    , name = convertName field.name\n                                    , globalAlias =\n                                        field.alias_\n                                            |> Maybe.withDefault field.name\n                                            |> convertName\n                                    , selectsOnlyFragment = Nothing\n                                    , arguments = []\n                                    , directives = List.map convertDirective field.directives\n                                    , wrapper = GraphQL.Schema.UnwrappedValue\n                                    , selection =\n                                        Can.FieldScalar (GraphQL.Schema.Scalar \"typename\")\n                                    }\n                        in\n                        { result =\n                            cache\n                                |> ok (new :: existingFields)\n                        , variants = found.variants\n                        , capturedVariants = found.capturedVariants\n                        , typenameAlreadySelected = True\n                        }\n\n                    else\n                        let\n                            cannedResult =\n                                canonicalizeField refs\n                                    unionOrInterface\n                                    selection\n                                    found.result\n                        in\n                        { result = cannedResult\n                        , variants = found.variants\n                        , capturedVariants = found.capturedVariants\n                        , typenameAlreadySelected = found.typenameAlreadySelected\n                        }\n\n                AST.FragmentSpreadSelection frag ->\n                    let\n                        fragName =\n                            AST.nameToString frag.name\n                    in\n                    case Dict.get fragName refs.fragments of\n                        Nothing ->\n                            { result =\n                                err\n                                    [ Error.error <|\n                                        Error.FragmentNotFound\n                                            { found = fragName\n                                            , object = unionOrInterface.name\n                                            , options =\n                                                Dict.values refs.fragments\n                                            }\n                                    ]\n                            , variants = found.variants\n                            , capturedVariants = found.capturedVariants\n                            , typenameAlreadySelected = found.typenameAlreadySelected\n                            }\n\n                        Just foundFrag ->\n                            if Can.nameToString foundFrag.typeCondition == unionOrInterface.name then\n                                let\n                                    new =\n                                        Can.Frag\n                                            { fragment = foundFrag\n                                            , directives =\n                                                frag.directives\n                                                    |> List.map\n                                                        convertDirective\n                                            }\n                                in\n                                { result =\n                                    cache\n                                        |> Cache.addFragment\n                                            { fragment = foundFrag\n                                            , alongsideOtherFields = False\n                                            }\n                                        |> ok (new :: existingFields)\n                                , variants = found.variants\n                                , capturedVariants = found.capturedVariants\n                                , typenameAlreadySelected = found.typenameAlreadySelected\n                                }\n\n                            else\n                                { result =\n                                    err\n                                        [ Error.error <|\n                                            Error.FragmentNotFound\n                                                { found = fragName\n                                                , object = unionOrInterface.name\n                                                , options =\n                                                    Dict.values refs.fragments\n                                                }\n                                        ]\n                                , variants = found.variants\n                                , capturedVariants = found.capturedVariants\n                                , typenameAlreadySelected = found.typenameAlreadySelected\n                                }\n\n                AST.InlineFragmentSelection inline ->\n                    case inline.selection of\n                        [] ->\n                            { result =\n                                err [ Error.error (Error.EmptyUnionVariantSelection { tag = AST.nameToString inline.tag }) ]\n                            , variants = found.variants\n                            , capturedVariants = found.capturedVariants\n                            , typenameAlreadySelected = found.typenameAlreadySelected\n                            }\n\n                        _ ->\n                            let\n                                tag =\n                                    AST.nameToString inline.tag\n\n                                ( tagMatches, leftOvertags ) =\n                                    matchTag tag found.variants ( False, [] )\n                            in\n                            if tagMatches then\n                                case Dict.get tag refs.schema.objects of\n                                    Nothing ->\n                                        { result =\n                                            err [ Error.error (Error.ObjectUnknown tag) ]\n                                        , variants = leftOvertags\n                                        , capturedVariants = found.capturedVariants\n                                        , typenameAlreadySelected = found.typenameAlreadySelected\n                                        }\n\n                                    Just obj ->\n                                        let\n                                            selectsForTypename =\n                                                if found.typenameAlreadySelected then\n                                                    True\n\n                                                else\n                                                    List.any\n                                                        (\\sel ->\n                                                            case sel of\n                                                                AST.Field firstField ->\n                                                                    case AST.nameToString firstField.name of\n                                                                        \"__typename\" ->\n                                                                            True\n\n                                                                        _ ->\n                                                                            False\n\n                                                                _ ->\n                                                                    False\n                                                        )\n                                                        inline.selection\n\n                                            selectionResult =\n                                                List.foldl\n                                                    (canonicalizeField refs obj)\n                                                    (cache\n                                                        |> Cache.addLevelKeepSiblingStack\n                                                            { name = tag\n                                                            , isAlias = False\n                                                            }\n                                                        |> ok []\n                                                    )\n                                                    inline.selection\n                                        in\n                                        if selectsForTypename then\n                                            case selectionResult of\n                                                CanSuccess selectionCache canSelection ->\n                                                    let\n                                                        global =\n                                                            selectionCache\n                                                                |> Cache.dropLevelNotSiblings\n                                                                |> Cache.getGlobalName tag\n\n                                                        globalDetailsAlias =\n                                                            global.used\n                                                                |> Cache.getGlobalName (global.globalName ++ \"_Details\")\n                                                    in\n                                                    { result =\n                                                        CanSuccess globalDetailsAlias.used existingFields\n                                                    , capturedVariants =\n                                                        { tag = Can.Name tag\n                                                        , globalTagName = Can.Name global.globalName\n                                                        , globalDetailsAlias = Can.Name globalDetailsAlias.globalName\n                                                        , directives = List.map convertDirective inline.directives\n                                                        , selection = canSelection\n                                                        }\n                                                            :: found.capturedVariants\n                                                    , variants = leftOvertags\n                                                    , typenameAlreadySelected = found.typenameAlreadySelected\n                                                    }\n\n                                                CanError errorMsg ->\n                                                    { result =\n                                                        CanError errorMsg\n                                                    , capturedVariants = found.capturedVariants\n                                                    , variants = leftOvertags\n                                                    , typenameAlreadySelected = found.typenameAlreadySelected\n                                                    }\n\n                                        else\n                                            { result =\n                                                err [ Error.error (Error.MissingTypename { tag = AST.nameToString inline.tag }) ]\n                                            , capturedVariants = found.capturedVariants\n                                            , variants = found.variants\n                                            , typenameAlreadySelected = found.typenameAlreadySelected\n                                            }\n\n                            else\n                                { result =\n                                    err [ Error.todo (tag ++ \" does not match!\") ]\n                                , variants = found.variants\n                                , capturedVariants = found.capturedVariants\n                                , typenameAlreadySelected = found.typenameAlreadySelected\n                                }\n\n\nmatchTag : String -> List String -> ( Bool, List String ) -> ( Bool, List String )\nmatchTag tag tags ( matched, captured ) =\n    case tags of\n        [] ->\n            ( matched, captured )\n\n        top :: remain ->\n            if top == tag then\n                ( True, remain ++ captured )\n\n            else\n                matchTag tag\n                    remain\n                    ( matched, top :: captured )\n"